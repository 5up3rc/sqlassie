/*
 * SQLassie - database firewall
 * Copyright (C) 2011 Brandon Skari <brandon.skari@gmail.com>
 *
 * This file is part of SQLassie.
 *
 * SQLassie is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SQLassie is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SQLassie. If not, see <http://www.gnu.org/licenses/>.
 */

// This needs to be defined prior to including the scanner header
#define YY_DECL int sql_lex( \
    ScannerContext* const context, \
    yyscan_t yyscanner \
)

#include "clearStack.hpp"
#include "nullptr.hpp"
#include "sqlParser.h"
#include "ParserInterface.hpp"
#include "scanner.yy.hpp"

#include <cassert>
#include <exception>
#ifndef NDEBUG
#include <iostream>
#include <stack>
#endif
#include <string>

using boost::lock_guard;
using std::bad_alloc;
using std::size_t;
using std::string;

// Methods from the parser
extern void* sqlassieParseAlloc(void* (*allocProc)(size_t numBytes));
extern void* sqlassieParse(
    void* parser,
    int token,
    const char* identifier,
    ScannerContext* qrPtr
);
extern void* sqlassieParseFree(void* parser, void(*freeProc)(void*));
// Methods from the scanner
extern YY_DECL;

/**
 * Hide some scanner members behind a PIMPL so that I don't have to worry
 * about dependency issues in my Makefile. Long explanation: I'm using a
 * script to update my Makefile dependencies. I used to include
 * scanner.yy.hpp, the header file generated by Flex, in ParserInterface's
 * header file. However, my script only looks at cpp dependencies because
 * it assumes that header files are static and not dynamically generated,
 * which works just fine for the other 99% of my files but doesn't work for
 * Flex. Anyway, I'm just going to hide the scanner's members here so that I
 * can break that nasty dependency.
 */
class ParserInterfaceScannerMembers
{
public:
    explicit ParserInterfaceScannerMembers(const char* const query);
    ~ParserInterfaceScannerMembers();
    yyscan_t scanner_;
    YY_BUFFER_STATE bufferState_;
private:
    ParserInterfaceScannerMembers(const ParserInterfaceScannerMembers&);
    ParserInterfaceScannerMembers& operator=(
        const ParserInterfaceScannerMembers&
    );
};


ParserInterface::ParserInterface(const string& buffer)
    : qr_()
    , scannerContext_(&qr_)
    , scannerPimpl_(new ParserInterfaceScannerMembers(buffer.c_str()))
    , tokensHash_()
    , parsed_(false)
    , successfullyParsed_(false)
    , bufferLen_(buffer.size())
    , lemonParser_(sqlassieParseAlloc(malloc))
{
    if (nullptr == lemonParser_)
    {
        delete scannerPimpl_;
        throw bad_alloc();
    }
}


ParserInterface::~ParserInterface()
{
    delete scannerPimpl_;
    sqlassieParseFree(lemonParser_, free);
}


bool ParserInterface::parse(QueryRisk* const qrPtr)
{
    assert(NULL != qrPtr);
    if (parsed_)
    {
        *qrPtr = qr_;
        return successfullyParsed_;
    }

    // Clear the stacks before every parsing attempt
    clearStack(&scannerContext_.identifiers);
    clearStack(&scannerContext_.quotedStrings);
    clearStack(&scannerContext_.numbers);

    int lexToken;
    do
    {
        lexToken = getLexValue();
        // We want to keep reading all of the tokens, even if parsing has
        // failed, but if parsing has already failed, don't keep calling it
        if (qr_.valid)
        {
            sqlassieParse(lemonParser_, lexToken, nullptr, &scannerContext_);
        }
    }
    while (lexToken != 0);

    #ifndef NDEBUG
        if (qr_.valid)
        {
            std::stack<string>* refs[] = {
                &scannerContext_.identifiers,
                &scannerContext_.quotedStrings,
                &scannerContext_.numbers,
                &scannerContext_.hexNumbers
            };
            for (size_t i = 0; i < sizeof(refs) / sizeof(refs[0]); ++i)
            {
                if (!refs[i]->empty())
                {
                    while (!refs[i]->empty())
                    {
                        std::cout << refs[i]->top() << '\n';
                        refs[i]->pop();
                    }
                    assert(false && "Stack not empty");
                }
            }
        }
    #endif

    *qrPtr = qr_;
    successfullyParsed_ = qr_.valid;
    parsed_ = true;

    // If the parser failed, we still need to manually calculate the rest of
    // the hash for this query. That calculation is handled in getLexValue, so
    // just keep calling that ourselves until it hits the end of the buffer.
    if (!successfullyParsed_)
    {
        const int END_OF_TOKENS = 0;
        while (getLexValue() != END_OF_TOKENS);
    }

    return successfullyParsed_;
}


ParserInterface::QueryHash ParserInterface::getHash() const
{
    assert(parsed_ && "gethash() called before parse(QueryRisk* const)");
    return tokensHash_;
}


ParserInterface::QueryHash::QueryHash() :
    hash(0),
    tokensCount(0)
{
}


bool operator==(
    const ParserInterface::QueryHash& hash1,
    const ParserInterface::QueryHash& hash2
)
{
    return hash1.hash == hash2.hash
        && hash1.tokensCount == hash2.tokensCount;
}


size_t hash_value(const ParserInterface::QueryHash& qh)
{
    return static_cast<std::size_t>(qh.hash + qh.tokensCount);
}


ParserInterfaceScannerMembers::ParserInterfaceScannerMembers(
    const char* const query
) :
    scanner_(),
    bufferState_(nullptr)
{
    if (0 != sql_lex_init(&scanner_))
    {
        throw bad_alloc();
    }
    bufferState_ = sql__scan_string(query, scanner_);
    if (nullptr == bufferState_)
    {
        sql_lex_destroy(scanner_);
        throw bad_alloc();
    }
}


ParserInterfaceScannerMembers::~ParserInterfaceScannerMembers()
{
    sql__delete_buffer(bufferState_, scanner_);
    sql_lex_destroy(scanner_);
}


/**
 * Calculates the partial sdbm hash, given a new lexeme.
 * @param lexCode The new lexeme from the buffer stream.
 * @param ht The previous hash.
 */
static ParserInterface::hashType sdbmHash(
    const int lexCode,
    const ParserInterface::hashType ht
);


int ParserInterface::getLexValue()
{
    int lexCode = sql_lex(
        &scannerContext_,
        scannerPimpl_->scanner_
    );
    // Don't calculate the hash anymore once we've hit the end of the buffer
    if (0 == lexCode)
    {
        ++tokensHash_.tokensCount;
        tokensHash_.hash = sdbmHash(lexCode, tokensHash_.hash);
    }
    return lexCode;
}


static ParserInterface::hashType sdbmHash(
    const int lexCode,
    const ParserInterface::hashType ht
)
{
    return lexCode + (ht << 6) + (ht << 16) - ht;
}
